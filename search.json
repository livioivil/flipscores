[{"path":"https://livioivil.github.io/flipscores/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Livio Finos. Maintainer, author. Jelle J. Goeman. Contributor. Jesse Hemerik. Contributor. Riccardo De Santis. Contributor.","code":""},{"path":"https://livioivil.github.io/flipscores/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hemerik J, Goeman J, Finos L (2020). “Robust testing generalized linear models sign-flipping score contributions.” Journal Royal Statistical Society: Series B (Statistical Methodology), 82(3), 841-864. doi:10.1111/rssb.12369. De Santis R, Goeman J, Hemerik J, Davenport S, Finos L (2025). “Inference Generalized Linear Models Robustness Misspecified Variances.” Journal American Statistical Association, press, 1-10. doi:10.1080/01621459.2025.2491775.","code":"@Article{,   title = {Robust testing in generalized linear models by sign-flipping score contributions},   author = {J. Hemerik and J. J. Goeman and L. Finos},   journal = {Journal of the Royal Statistical Society: Series B (Statistical Methodology)},   year = {2020},   volume = {82},   number = {3},   pages = {841-864},   doi = {10.1111/rssb.12369}, } @Article{,   title = {Inference in Generalized Linear Models with Robustness to Misspecified Variances},   author = {R. {De Santis} and J. J. Goeman and J. Hemerik and S. Davenport and L. Finos},   journal = {Journal of the American Statistical Association},   year = {2025},   volume = {in press},   pages = {1-10},   doi = {10.1080/01621459.2025.2491775}, }"},{"path":"https://livioivil.github.io/flipscores/index.html","id":"the-flipscores-package-","dir":"","previous_headings":"","what":"Robust Score Testing in GLMs, by Sign-Flip Contributions","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"CRAN version","code":""},{"path":"https://livioivil.github.io/flipscores/index.html","id":"set-up","dir":"","previous_headings":"","what":"Set up","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"install github version type (R):","code":"##if devtools is not installed yet:  ## install.packages(\"devtools\")  library(devtools) install_github(\"livioivil/flipscores\")"},{"path":"https://livioivil.github.io/flipscores/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"J Hemerik, JJ Goeman L Finos (2019) Robust testing generalized linear models sign-flipping score contributions. Journal Royal Statistical Society Series B: Statistical Methodology, Volume 82, Issue 3, July 2020, Pages 841–864.https://doi.org/10.1111/rssb.12369 De Santis, R., Goeman, J. J., Hemerik, J., Davenport, S., & Finos, L. (2025). Inference Generalized Linear Models Robustness Misspecified Variances. Journal American Statistical Association, 1–10. https://doi.org/10.1080/01621459.2025.2491775","code":""},{"path":"https://livioivil.github.io/flipscores/index.html","id":"some-examples","dir":"","previous_headings":"","what":"Some examples","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"","code":"library(flipscores) set.seed(1) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rpois(n=20,lambda=exp(dt$X)) mod=flipscores(Y~Z+X,data=dt,family=\"poisson\",x=TRUE) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"poisson\", data = dt,  #>     x = TRUE) #>  #> Coefficients: #>             Estimate   Score Std. Error z value Part. Cor Pr(>|z|)   #> (Intercept)  -0.1026 -0.7229     2.7127 -0.2665    -0.088   0.7454   #> ZB           -0.1501 -0.7125     2.1789 -0.3270    -0.104   0.6456   #> ZC            0.1633  0.8106     2.2232  0.3646     0.117   0.6908   #> X             0.9439 16.2058     4.7272  3.4282     0.671   0.0104 * #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 27.135  on 19  degrees of freedom #> Residual deviance: 12.888  on 16  degrees of freedom #> AIC: 57.459 #>  #> Number of Fisher Scoring iterations: 5  # Anova test anova(mod) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model: Y ~ Z + X #>   Df   Score Pr(>Score)   #> Z  2 0.74371     0.6986   #> X  1 0.02941     0.0104 * #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 # or mod0=flipscores(Y~Z,data=dt,family=\"poisson\",x=TRUE) anova(mod0,mod) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model 1: Y ~ Z #> Model 2: Y ~ Z + X #>                    Df    Score Pr(>Score)   #> Model 2 vs Model 1  1 0.029274     0.0114 * #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 # and mod0=flipscores(Y~X,data=dt,family=\"poisson\") anova(mod0,mod) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model 1: Y ~ X #> Model 2: Y ~ Z + X #>                    Df Score Pr(>Score) #> Model 2 vs Model 1  2 1.445      0.514"},{"path":"https://livioivil.github.io/flipscores/index.html","id":"negative-binomial","dir":"","previous_headings":"Some examples","what":"Negative Binomial","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"","code":"set.seed(1) D=data.frame(x=(1:40)/20, z=rnorm(40)) D$y=rnbinom(40,mu=exp(D$x),size=3)  library(MASS) mod_par=glm.nb(y~x+z,data=D, link=\"log\") summary(mod_par) #>  #> Call: #> glm.nb(formula = y ~ x + z, data = D, link = \"log\", init.theta = 7.972747099) #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -0.15365    0.29358  -0.523    0.601     #> x            0.92089    0.21481   4.287 1.81e-05 *** #> z           -0.01282    0.13606  -0.094    0.925     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for Negative Binomial(7.9727) family taken to be 1) #>  #>     Null deviance: 61.217  on 39  degrees of freedom #> Residual deviance: 41.312  on 37  degrees of freedom #> AIC: 154.29 #>  #> Number of Fisher Scoring iterations: 1 #>  #>  #>               Theta:  7.97  #>           Std. Err.:  6.95  #>  #>  2 x log-likelihood:  -146.286 mod=flipscores(y~x+z, data=D, family = \"negbinom\")  summary(mod) #>  #> Call: #> flipscores(formula = y ~ x + z, family = \"negbinom\", data = D) #>  #> Coefficients: #>             Estimate    Score Std. Error  z value Part. Cor Pr(>|z|)    #> (Intercept) -0.15365 -1.84162    3.42399 -0.53786    -0.087   0.5864    #> x            0.92089 14.93128    4.42610  3.37346     0.547   0.0016 ** #> z           -0.01282 -0.72457    7.24491 -0.10001    -0.016   0.9584    #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for Negative Binomial(7.9727) family taken to be 0.9960228) #>  #>     Null deviance: 61.217  on 39  degrees of freedom #> Residual deviance: 41.312  on 37  degrees of freedom #> AIC: 154.29 #>  #> Number of Fisher Scoring iterations: 1"},{"path":"https://livioivil.github.io/flipscores/index.html","id":"bug-reports","dir":"","previous_headings":"","what":"Bug reports","title":"Robust Score Testing in GLMs, by Sign-Flip Contributions","text":"encounter bug, please file reprex (minimal reproducible example) github.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/anova.flipscores.html","id":null,"dir":"Reference","previous_headings":"","what":"anova.flipscores — anova.flipscores","title":"anova.flipscores — anova.flipscores","text":"anova method flipscores object. Remark: performs type III deviance decomposition car::Anova.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/anova.flipscores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"anova.flipscores — anova.flipscores","text":"","code":"# S3 method for class 'flipscores' anova(object, model1 = NULL, score_type = NULL, n_flips = 5000, id = NULL, ...)"},{"path":"https://livioivil.github.io/flipscores/reference/anova.flipscores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"anova.flipscores — anova.flipscores","text":"object (object) glm (flipscores) object model null hypothesis (.e. covariates, nuisance parameters). model1 glm (flipscores) matrix (vector). glm object, model alternative hypothesis. variables model1 variables object plus one variables tested.  Alternatively, model1 matrix, contains tested variables column-wise. score_type type score computed. can \"orthogonalized\", \"effective\" \"basic\". Default \"orthogonalized\". \"effective\" \"orthogonalized\" take account nuisance estimation. default NULL, case value taken object. n_flips number random flips score contributions. n_flips equal larger maximum number possible flips (.e. n^2), possible flips performed. Default 5000. id vector identifying clustered observations. NULL (default) observations assumed independent. NOTE: object flipscores model$flip_param_call$id NULL, considered inference. ... parameters allowed stats::anova.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/anova.flipscores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"anova.flipscores — anova.flipscores","text":"","code":"set.seed(1) dt=data.frame(X=scale(rnorm(50)),    Z=factor(rep(LETTERS[1:3],length.out=50))) dt$Y=rpois(n=nrow(dt),lambda=exp(dt$X*(dt$Z==\"C\"))) mod0=flipscores(Y~Z+X,data=dt,family=\"poisson\") summary(mod0) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"poisson\", data = dt) #>  #> Coefficients: #>             Estimate   Score Std. Error z value Part. Cor Pr(>|z|)    #> (Intercept)  -0.3513 -5.4234     4.2404 -1.2790    -0.169   0.1166    #> ZB            0.2276  1.8048     2.8140  0.6414     0.079   0.4576    #> ZC            0.9034 10.3392     3.4527  2.9945     0.348   0.0230 *  #> X             0.6381 33.1168     8.0470  4.1154     0.478   0.0092 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 82.225  on 49  degrees of freedom #> Residual deviance: 52.798  on 46  degrees of freedom #> AIC: 143.12 #>  #> Number of Fisher Scoring iterations: 5 #>  anova(mod0) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model: Y ~ Z + X #>   Df  Score Pr(>Score)    #> Z  2 4.3880     0.0964 .  #> X  1 0.0341     0.0092 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1  mod1=flipscores(Y~Z*X,data=dt,family=\"poisson\") summary(mod1) #>  #> Call: #> flipscores(formula = Y ~ Z * X, family = \"poisson\", data = dt) #>  #> Coefficients: #>             Estimate   Score Std. Error z value Part. Cor Pr(>|z|)   #> (Intercept)  -0.3549 -4.3865     3.8867 -1.1286    -0.189   0.0866 . #> ZB            0.3570  2.3488     2.6093  0.9002     0.145   0.3058   #> ZC            0.6023  3.3952     2.3099  1.4698     0.235   0.0674 . #> X             0.6439  8.1773     3.6816  2.2211     0.331   0.1276   #> ZB:X         -0.5979 -3.8933     2.5112 -1.5504    -0.238   0.3524   #> ZC:X          0.4856  2.8440     2.4290  1.1709     0.184   0.2300   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 82.225  on 49  degrees of freedom #> Residual deviance: 44.750  on 44  degrees of freedom #> AIC: 139.07 #>  #> Number of Fisher Scoring iterations: 5 #>  anova(mod0,model1 = mod1) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model 1: Y ~ Z + X #> Model 2: Y ~ Z * X #>                    Df Score Pr(>Score)   #> Model 2 vs Model 1  2 4.689     0.0694 . #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"Computes normalized generalized partial correlation coefficient binomial GLMs. normalization scales correlation maximum possible absolute value.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"","code":"compute_gcor_normalized_binom(   model0,   X,   algorithm = \"auto\",   algorithm.control = list(n_exact = 15, thresholds = c(-0.1, 0, 0.1), n_random = 10,     max_iter = 1000, topK = 10, tol = 1e-12, patience = 10),   ... )"},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"algorithm `\"auto\"` default. choose `\"intercept_only\"`, `\"brute_force\"` `\"multi_start\"` algorithm.control `list` coltrol parameters: `n_exact` Integer specifying sample size threshold using exact   methods (brute force). Default 15. `thresholds` Numeric vector threshold values multi-start initialization. `n_random` Integer number random starts multi-start optimization. `max_iter` Integer maximum number iterations per start. `topK` Integer number top candidates consider iteration. `tol` Numeric tolerance convergence. `patience` Integer number iterations without improvement stopping. full_glm fitted GLM object class `glm` binomial family. terms Character vector variable names compute normalized correlations. `NULL` (default), computes non-intercept terms model. intercept_too Logical indicating whether include intercept variable. Default FALSE.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"data frame five columns: terms variable name r generalized partial correlation coefficient r_n normalized generalized partial correlation coefficient null_model null model used compute generalized (partial) correlation algorithm algorithm used compute upper/lower bounds generalized partial correlation coefficient (compute normalized version)","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"normalized generalized partial correlation computed : $$ r_n = \\begin{cases} +r / r_+ & \\text{} r > 0 \\\\ -r / r_- & \\text{} r < 0 \\end{cases} $$ \\(r_+\\) maximum possible correlation \\(r_-\\) minimum. (full) model intercept one predictor X, generalized (non partial) correlation computed normalization factor X exact. general case predictors, sample sizes \\(n \\leq n_{\\text{exact}}\\), brute force search used find exact extrema. larger sample sizes, greedy multi-start algorithm employed: Multiple starting points generated using thresholding random sampling start, coordinates greedily flipped improve correlation Early stopping used improvements found several iterations best solution across starts returned approach provides good trade-computational efficiency solution quality large problems brute force infeasible.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_gcor_normalized_binom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalized Generalized Partial Correlation for Binomial GLMs — compute_gcor_normalized_binom","text":"","code":"set.seed(123) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rbinom(n=20,prob=plogis((dt$Z==\"C\")*2),size=1) mod=flipscores(Y~Z+X,data=dt,family=\"binomial\",n_flips=1000) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"binomial\", data = dt,  #>     n_flips = 1000) #>  #> Coefficients: #>             Estimate    Score Std. Error  z value Part. Cor Pr(>|z|)   #> (Intercept)  -0.1486  -0.2102     1.1881  -0.1770    -0.067    0.910   #> ZB          -20.4539  -1.4784     0.7466  -1.9802    -0.530    0.057 . #> ZC           20.8561   1.8043     0.8180   2.2057     0.615    0.037 * #> X            -0.4276  -0.3782     0.9574  -0.3951    -0.149    0.735   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 27.5256  on 19  degrees of freedom #> Residual deviance:  9.4015  on 16  degrees of freedom #> AIC: 17.401 #>  #> Number of Fisher Scoring iterations: 19 #>   (results <- gcor_normalized_binom(mod)) #> Error in gcor_normalized_binom(mod): could not find function \"gcor_normalized_binom\" # Compute for specific terms only gcor_normalized_binom(mod, terms = c(\"X\", \"ZC\")) #> Error in gcor_normalized_binom(mod, terms = c(\"X\", \"ZC\")): could not find function \"gcor_normalized_binom\""},{"path":"https://livioivil.github.io/flipscores/reference/compute_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"compute_scores — compute_scores","title":"compute_scores — compute_scores","text":"usage anova.glm. parameter id  used , present model0 (priority) model1.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"compute_scores — compute_scores","text":"","code":"compute_scores(model0, model1, score_type = \"standardized\", ...)"},{"path":"https://livioivil.github.io/flipscores/reference/compute_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"compute_scores — compute_scores","text":"model0 glm object model null hypothesis (.e. covariates, nuisance parameters). model1 glm matrix (vector). glm object, model alternative hypothesis. variables model1 variables model0 plus one variables tested.  Alternatively, model1 matrix, contains tested variables column-wise. score_type type score computed. \"orthogonalized\", \"effective\" \"basic\". \"effective\" \"orthogonalized\" take account nuisance estimation. ... arguments.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_scores.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"compute_scores — compute_scores","text":"Jesse Hemerik, Riccardo De Santis, Vittorio Giatti, Jelle Goeman Livio Finos","code":""},{"path":"https://livioivil.github.io/flipscores/reference/compute_scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"compute_scores — compute_scores","text":"","code":"set.seed(1) Z=rnorm(20) X=Z+rnorm(20) Y=rpois(n=20,lambda=exp(Z+X)) mod0=glm(Y~Z,family=\"poisson\") X=data.frame(X=X) scr0=compute_scores(model0 = mod0, model1 = X) head(scr0) #>             X #> 1 -0.09157255 #> 2  1.29487548 #> 3  0.14949028 #> 4 46.19093971 #> 5  1.30167541 #> 6  0.18155826"},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"Computes normalized generalized R-squared coefficient binomial GLMs. normalization scales R-squared maximum possible value specified set terms.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"","code":".socket_compute_gR2_n(terms, full_glm, null_glm = NULL, algorithm, control)"},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"terms Character vector variable names compute normalized R-squared. `NULL` (default), computes non-intercept terms model. full_glm fitted GLM object class `glm` binomial family. null_glm fitted GLM object class `glm` (null model). `NULL` (default), uses empty model (intercept-intercept present, otherwise predictors). algorithm `\"auto\"` default. chooses `\"brute_force\"` `\"multi_start\"` algorithm.control `list` control parameters: `n_exact` Integer specifying sample size threshold using exact     methods (brute force). Default 15. `thresholds` Numeric vector threshold values multi-start initialization. `n_random` Integer number random starts multi-start optimization. `max_iter` Integer maximum number iterations per start. `topK` Integer number top candidates consider iteration. `tol` Numeric tolerance convergence. `patience` Integer number iterations without improvement stopping.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"list components: R2 generalized R-squared coefficient set terms R2_n normalized generalized R-squared coefficient algorithm algorithm used compute maximum R-squared terms_tested names terms included test","code":""},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"normalized generalized R-squared computed : $$ R^2_n = \\frac{R^2}{R^2_{\\max}} $$ \\(R^2_{\\max}\\) maximum possible R-squared value specified set terms. Different algorithms used based sample size: small samples (\\(n \\leq n_{\\text{exact}}\\)), brute force search finds exact maximum larger samples, greedy multi-start algorithm finds approximate maximum","code":""},{"path":"https://livioivil.github.io/flipscores/reference/dot-socket_compute_gR2_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalized Generalized R-squared for Binomial GLMs — .socket_compute_gR2_n","text":"","code":"set.seed(123) dt <- data.frame(X = rnorm(20),                  Z = factor(rep(LETTERS[1:3], length.out = 20))) dt$Y <- rbinom(n = 20, prob = plogis((dt$Z == \"C\") * 2), size = 1) mod <- glm(Y ~ Z + X, data = dt, family = binomial)  # Compute generalized partial correlations for all variables (results <-  gR2_normalized_binom(mod)) #> Error in gR2_normalized_binom(mod): could not find function \"gR2_normalized_binom\" # equivalent to mod0=glm(Y~1,data=dt,family=binomial) (results <-  gR2_normalized_binom(mod, mod0)) #> Error in gR2_normalized_binom(mod, mod0): could not find function \"gR2_normalized_binom\"  # Compute for specific variables only (results <-  gR2_normalized_binom(mod,terms = c(\"X\",\"Z\"))) #> Error in gR2_normalized_binom(mod, terms = c(\"X\", \"Z\")): could not find function \"gR2_normalized_binom\""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for flipscores objects — flipscores-method","title":"Methods for flipscores objects — flipscores-method","text":"Methods flipscores objects. following methods extract manipulate relevant information flipscores object.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for flipscores objects — flipscores-method","text":"","code":"# S3 method for class 'flipscores' print(x, ...)  # S3 method for class 'flipscores' summary(object, ...)"},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for flipscores objects — flipscores-method","text":"x flipscores object ... additional arguments passed object flipscores object","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-package.html","id":null,"dir":"Reference","previous_headings":"","what":"flipscores: Robust Score Testing in GLMs, by Sign-Flip Contributions — flipscores-package","title":"flipscores: Robust Score Testing in GLMs, by Sign-Flip Contributions — flipscores-package","text":"Provides robust tests testing GLMs, sign-flipping score contributions. tests robust overdispersion, heteroscedasticity , cases, ignored nuisance variables. See Hemerik, Goeman Finos (2020) doi:10.1111/rssb.12369 . provides robust tests testing GLMs, sign-flipping score contributions. tests often robust overdispersion, heteroscedasticity , cases, ignored nuisance variables.","code":""},{"path":[]},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"flipscores: Robust Score Testing in GLMs, by Sign-Flip Contributions — flipscores-package","text":"Maintainer: Livio Finos livio.finos@unipd.(ORCID) contributors: Jelle J. Goeman [contributor] Jesse Hemerik [contributor] Riccardo De Santis [contributor] Livio Finos, Jelle Goeman Jesse Hemerik, contribution Riccardo De Santis.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"flipscores: Robust Score Testing in GLMs, by Sign-Flip Contributions — flipscores-package","text":"","code":"set.seed(1) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rpois(n=20,lambda=exp(dt$X)) mod=flipscores(Y~Z+X,data=dt,family=\"poisson\",x=TRUE) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"poisson\", data = dt,  #>     x = TRUE) #>  #> Coefficients: #>             Estimate   Score Std. Error z value Part. Cor Pr(>|z|)   #> (Intercept)  -0.1026 -0.7229     2.7127 -0.2665    -0.088   0.7438   #> ZB           -0.1501 -0.7125     2.1789 -0.3270    -0.104   0.6532   #> ZC            0.1633  0.8106     2.2232  0.3646     0.117   0.6876   #> X             0.9439 16.2058     4.7272  3.4282     0.671   0.0126 * #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 27.135  on 19  degrees of freedom #> Residual deviance: 12.888  on 16  degrees of freedom #> AIC: 57.459 #>  #> Number of Fisher Scoring iterations: 5 #>   # Anova test anova(mod) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model: Y ~ Z + X #>   Df   Score Pr(>Score)   #> Z  2 0.74835     0.6950   #> X  1 0.02950     0.0126 * #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 # or mod0=flipscores(Y~Z,data=dt,family=\"poisson\",x=TRUE) anova(mod0,mod) #> Analysis of Deviance Table (Type III test) #>  #> Model: poisson, link: log #>  #> Inference is provided by FlipScores approach (5000 sign flips). #>  #> Model 1: Y ~ Z #> Model 2: Y ~ Z + X #>                    Df    Score Pr(>Score)   #> Model 2 vs Model 1  1 0.029296     0.0144 * #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 # and mod0=flipscores(Y~X,data=dt,family=\"poisson\") anova(mod0,mod) #> Error in model.frame.default(formula = Y ~ X, data = dt, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list"},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"Provides robust tests testing GLMs, sign-flipping score contributions. tests often robust overdispersion, heteroscedasticity , cases, ignored nuisance variables.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"","code":"flipscores(formula, family, data, score_type = \"standardized\", n_flips = 5000, alternative = \"two.sided\", id = NULL, seed = NULL, to_be_tested = NULL, flips = NULL, precompute_flips=TRUE, ...)"},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"formula see glm function. can also model (usually generated call glm); case, glm-related parameter (e.g. family, data, etc.) discarded, function make use ones used generate model. (.e. formula, family, data, etc) considered.  NULL default (.e. used). family see glm function. data see glm function. score_type type score computed. can \"standardized\" \"orthogonalized\", \"effective\" \"basic\". \"orthogonalized\" \"effective\" take account nuisance estimation provide test statistic. case small samples \"effective score\" might slight anti-conservative behaviour. \"standardized effective score\" gives solution issue. \"orthogonalized\" similar intent, note however case big model matrix, may slow. n_flips number random flips score contributions. Overwritten nrow(flips) flips NULL (see parameter flips details). n_flips equal larger maximum number possible flips (.e. n^2), possible flips performed. alternative can \"greater\", \"less\" \"two.sided\" (default) id vector identifying clustered observations. NULL (default) observations assumed independent. id NULL, score_type==\"effective\" allowed, yet. seed NULL default. to_be_tested vector indices names coefficients glm model tested (faster computing every scores p-values course). flips matrix fo +1 -1, matrix n_flips rows n (number observations) columns precompute_flips TRUE default. Overwritten flips NULL. FALSE matrix flips computed flips made '--fly' computing test statistics; may usefull flips large (see parameter flips details). ... see glm function.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"object class flipscores. See also methods (summary.flipscores, anova.flipscores, print.flipscores).","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"flipscores borrows parameters function glm (glm.nb). See helps details parameters formula, data, family. Note: order use Negative Binomial family, family reference must quotes (.e. family=\"negbinom\").  Furthermore, flipscores object contains two extra elements: scores  – .e. matrix n score contributions, one column tested coefficient – Tspace – .e. matrix size n_flips times ncol(scores). fist row  Tspace contains column-wise test statistics generated randomly flipping score contributions, column refers column scores, vector observed test statistics (.e. flips) first row Tspace.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"\"Robust testing generalized linear models sign-flipping score contributions\" J.Hemerik, J.Goeman L.Finos.","code":""},{"path":[]},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"Livio Finos, Riccardo De Santis, Jesse Hemerik Jelle Goeman","code":""},{"path":"https://livioivil.github.io/flipscores/reference/flipscores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robust testing in GLMs, by sign-flipping score contributions — flipscores","text":"","code":"set.seed(1) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rpois(n=20,lambda=exp((dt$Z==\"C\") + 2*dt$X)) mod=flipscores(Y~Z+X,data=dt,family=\"poisson\",n_flips=1000) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"poisson\", data = dt,  #>     n_flips = 1000) #>  #> Coefficients: #>              Estimate     Score Std. Error   z value Part. Cor Pr(>|z|)    #> (Intercept)   0.04964   0.55830    3.32802   0.16776     0.064    0.797    #> ZB            0.20371   3.71436    4.27357   0.86915     0.326    0.168    #> ZC            0.87538  17.18530    4.43500   3.87493     0.856    0.002 ** #> X             1.95754 109.81199    9.92393  11.06538     0.749    0.003 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 187.2834  on 19  degrees of freedom #> Residual deviance:   7.4756  on 16  degrees of freedom #> AIC: 69.284 #>  #> Number of Fisher Scoring iterations: 5 #>   # Equivalent to: model=glm(Y~Z+X,data=dt,family=\"poisson\") mod2=flipscores(model) #> Error in model.frame.default(formula = Y ~ Z + X, data = dt, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list summary(mod2) #> Error: object 'mod2' not found"},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized R-squared for GLM Models — gR2","title":"Generalized R-squared for GLM Models — gR2","text":"Computes generalized R-squared measure nested generalized linear models. generalized R-squared measures proportion \"variance\" explained additional predictors full model compared null model.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized R-squared for GLM Models — gR2","text":"","code":"gR2(   full_glm,   null_glm = NULL,   terms = NULL,   normalize = FALSE,   adjusted = FALSE,   algorithm = \"auto\",   algorithm.control = list(n_exact = 15, thresholds = c(-0.1, 0, 0.1), n_random = max(1,     13 + log(1/nrow(model.matrix(full_glm)))), max_iter = 1000, topK = max(10, min(100,     length(nrow(model.matrix(full_glm)))/10)), tol = 1e-12, patience = 10) )"},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized R-squared for GLM Models — gR2","text":"full_glm fitted GLM object class `glm` (full model). null_glm fitted GLM object class `glm` (null model). `NULL` (default), uses empty model (intercept-intercept present, otherwise predictors). terms character vector variable names formula specifying additional terms full model compared null. provided, overrides `null_glm` null model refitted excluding terms. normalize FALSE default. algorithm `\"auto\"` default. choose `\"intercept_only\"`, `\"brute_force\"` `\"multi_start\"` algorithm.control `list` control parameters: `n_exact` Integer specifying sample size threshold using exact     methods (brute force). Default 15. `thresholds` Numeric vector threshold values multi-start initialization. `n_random` Integer number random starts multi-start optimization. `max_iter` Integer maximum number iterations per start. `topK` Integer number top candidates consider iteration. `tol` Numeric tolerance convergence. `patience` Integer number iterations without improvement stopping.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized R-squared for GLM Models — gR2","text":"normalize==FALSE: numeric value representing generalized R-squared measure. normalize==TRUE: list components: R2 generalized R-squared coefficient set terms R2_n normalized generalized R-squared coefficient algorithm algorithm used compute maximum R-squared terms_tested names terms included test","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized R-squared for GLM Models — gR2","text":"generalized R-squared computed : $$gR^2 = \\frac{Y_r^\\top X_r (X_r^\\top X_r)^{-1} X_r^\\top Y_r}{Y_r^\\top Y_r}$$ : \\(Y_r = V^{-1/2}(Y - \\hat{\\mu}_0)\\) standardized residual vector null model \\(X_r = (- H)W^{1/2}X\\) residualized additional predictors matrix \\(H\\) hat matrix null model \\(W = DV^{-1}D\\) weight matrix measures proportion standardized residual sum squares explained additional predictors full model. normalized generalized R-squared computed : $$ R^2_n = \\frac{R^2}{R^2_{\\max}} $$ \\(R^2_{\\max}\\) maximum possible R-squared value specified set terms. Different algorithms used based sample size: small samples (\\(n \\leq n_{\\text{exact}}\\)), brute force search finds exact maximum larger samples, greedy multi-start algorithm finds approximate maximum","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized R-squared for GLM Models — gR2","text":"Livio Finos Paolo Girardi","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gR2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized R-squared for GLM Models — gR2","text":"","code":"set.seed(1) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rpois(n=20,lambda=exp(dt$Z==\"C\")) mod=glm(Y~Z+X,data=dt,family=\"poisson\") summary(mod) #>  #> Call: #> glm(formula = Y ~ Z + X, family = \"poisson\", data = dt) #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)    #> (Intercept) -0.14256    0.40940  -0.348  0.72768    #> ZB          -0.18558    0.60570  -0.306  0.75931    #> ZC           1.40981    0.46298   3.045  0.00233 ** #> X           -0.06964    0.20905  -0.333  0.73906    #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 28.649  on 19  degrees of freedom #> Residual deviance: 11.218  on 16  degrees of freedom #> AIC: 58.102 #>  #> Number of Fisher Scoring iterations: 5 #>   # Compute generalized partial correlations for all variables (results <- gR2(mod)) #>           terms       gR2 null_model #> 1 ~ ZB + ZC + X 0.6957557      Y ~ 1 # equivalent to mod0=glm(Y~0,data=dt,family=\"poisson\") (results <- gR2(mod, mod0)) #>               terms       gR2 null_model #> 1 ~ 1 + ZB + ZC + X 0.8580193      Y ~ 0 (results <- gR2(mod, mod0,normalize=TRUE)) #> Warning: The Normalized Generalized Partial Correlation (Determination) Coefficient for Count families without interncept in the null model has not implemented, yet. NA will be returned. #>                         terms       gR2 gR2_n algorithm exact null_model #> 1 ~ (Intercept) + ZB + ZC + X 0.8580193    NA        NA    NA      Y ~ 0  # Compute for specific variables only (results <- gR2(mod,terms = c(\"X\",\"Z\"))) #> Error in model.frame.default(formula = Y ~ Z, data = dt, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list (results <- gR2(mod,terms = c(\"X\",\"Z\"))) #> Error in model.frame.default(formula = Y ~ Z, data = dt, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list   set.seed(123) dt <- data.frame(X = rnorm(20),                  Z = factor(rep(LETTERS[1:3], length.out = 20))) dt$Y <- rbinom(n = 20, prob = plogis((dt$Z == \"C\") * 2), size = 1) mod <- glm(Y ~ Z + X, data = dt, family = binomial)  # Compute generalized partial correlations for all variables (results <-  gR2(mod,normalize=TRUE)) #>           terms       gR2     gR2_n   algorithm exact null_model #> 1 ~ ZB + ZC + X 0.6553299 0.6553299 multi_start FALSE      Y ~ 1 # equivalent to mod0=glm(Y~1,data=dt,family=binomial) (results <-  gR2(mod, mod0,normalize=TRUE)) #>           terms       gR2     gR2_n   algorithm exact null_model #> 1 ~ ZB + ZC + X 0.6553299 0.6553299 multi_start FALSE      Y ~ 1  # Compute for specific variables only (results <-  gR2(mod,terms = c(\"X\",\"Z\"),normalize=TRUE)) #> Error in model.frame.default(formula = Y ~ 1 - 1, data = dt, drop.unused.levels = TRUE): 'data' must be a data.frame, environment, or list   # Compute generalized (non partial!) correlations for all variables mod <- glm(Y ~ X, data = dt, family = binomial) (results <-  gR2(mod,normalize=TRUE)) #>   terms          gR2        gR2_n   algorithm exact null_model #> 1   ~ X 0.0004224238 0.0006806998 multi_start FALSE      Y ~ 1 # note the difference: (results <-  gR2(mod,normalize=TRUE,algorithm=\"intercept_only\")) #>   terms          gR2        gR2_n      algorithm exact null_model #> 1   ~ X 0.0004224238 0.0006806998 intercept_only  TRUE      Y ~ 1 # Despite the result is the same in this case, # the multi_start algorithm does not ensure exactness (while intercept_only and brute_force do) (results <-  gR2(mod,normalize=TRUE,algorithm=\"multi_start\")) #>   terms          gR2        gR2_n   algorithm exact null_model #> 1   ~ X 0.0004224238 0.0006806998 multi_start FALSE      Y ~ 1"},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Generalized Partial Correlations for GLM terms — gcor","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"function computes generalized partial correlation coefficient \\(r\\) specified variable generalized linear model. variable, refits null model excluding variable computes cosine similarity residualized predictor standardized residuals.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"","code":"gcor(   full_glm,   terms = NULL,   normalize = FALSE,   intercept_too = FALSE,   algorithm = \"auto\",   algorithm.control = list(n_exact = 15, thresholds = c(-0.1, 0, 0.1), n_random = max(1,     13 + log(1/nrow(model.matrix(full_glm)))), max_iter = 1000, topK = max(10, min(100,     length(nrow(model.matrix(full_glm)))/10)), tol = 1e-12, patience = 10) )"},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"full_glm fitted GLM object class `glm`. terms Character vector variable names (referred model.matrix, pay attention factors) compute generalized partial correlations. `NULL` (default), computes non-intercept terms model. normalize FALSE default. intercept_too Logical indicating whether include intercept variable. Default FALSE. algorithm used normalize TRUE. `\"auto\"` default. choose `\"intercept_only\"`, `\"brute_force\"` `\"multi_start\"` algorithm.control used normalize TRUE. `list` control parameters: `n_exact` Integer specifying sample size threshold using exact   methods (brute force). Default 15. `thresholds` Numeric vector threshold values multi-start initialization. `n_random` Integer number random starts multi-start optimization. `max_iter` Integer maximum number iterations per start. `topK` Integer number top candidates consider iteration. `tol` Numeric tolerance convergence. `patience` Integer number iterations without improvement stopping.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"normalize FALSE, data frame five columns: variable variable name r generalized partial correlation coefficient normalize TRUE terms variable name r generalized partial correlation coefficient r_n normalized generalized partial correlation coefficient null_model null model used compute generalized (partial) correlation algorithm algorithm used compute upper/lower bounds generalized partial correlation coefficient (compute normalized version) exact logical","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"generalized partial correlation \\(\\r\\) measures association predictor response adjusting terms model. defined cosine similarity residualized predictor \\(X_r\\) standardized residuals \\(Y_r\\): $$\\r = \\frac{X_r^\\top Y_r}{\\|X_r\\| \\|Y_r\\|}$$ : \\(X_r = (- H)W^{1/2}X\\) residualized predictor \\(Y_r = V^{-1/2}(Y - \\hat{\\mu})\\) standardized residual vector \\(H\\) hat matrix nuisance covariates \\(W = DV^{-1}D\\) weight matrix \\(V\\) variance matrix \\(D\\) derivative matrix function uses `flipscores:::get_par_expo_fam()` compute \\(V\\) \\(D\\) consistently flipscores package methodology. normalized generalized partial correlation computed : $$ r_n = \\begin{cases} +r / r_+ & \\text{} r > 0 \\\\ -r / r_- & \\text{} r < 0 \\end{cases} $$ \\(r_+\\) maximum possible correlation \\(r_-\\) minimum. (full) model intercept one predictor X, generalized (non partial) correlation computed normalization factor X exact. general case predictors, sample sizes \\(n \\leq n_{\\text{exact}}\\), brute force search used find exact extrema. larger sample sizes, greedy multi-start algorithm employed: Multiple starting points generated using thresholding random sampling start, coordinates greedily flipped improve correlation Early stopping used improvements found several iterations best solution across starts returned approach provides good trade-computational efficiency solution quality large problems brute force infeasible.","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"Livio Finos Paolo Girardi","code":""},{"path":"https://livioivil.github.io/flipscores/reference/gcor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Generalized Partial Correlations for GLM terms — gcor","text":"","code":"set.seed(1) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rpois(n=20,lambda=exp(dt$Z==\"C\")) mod=flipscores(Y~Z+X,data=dt,family=\"poisson\",n_flips=1000) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"poisson\", data = dt,  #>     n_flips = 1000) #>  #> Coefficients: #>             Estimate    Score Std. Error  z value Part. Cor Pr(>|z|)    #> (Intercept) -0.14256 -0.91360    2.62144 -0.34851    -0.127    0.723    #> ZB          -0.18558 -0.50868    1.65785 -0.30683    -0.108    0.664    #> ZC           1.40981  8.55380    2.58950  3.30326     0.765    0.005 ** #> X           -0.06964 -1.56935    4.70999 -0.33320    -0.117    0.644    #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for poisson family taken to be 1) #>  #>     Null deviance: 28.649  on 19  degrees of freedom #> Residual deviance: 11.218  on 16  degrees of freedom #> AIC: 58.102 #>  #> Number of Fisher Scoring iterations: 5 #>   # Compute generalized partial correlations for all terms (results <- gcor(mod)) #>   terms       gcor null_model #> 1   ~ZB -0.1080979    ~1+ZC+X #> 2   ~ZC  0.7651942    ~1+ZB+X #> 3    ~X -0.1174534   ~1+ZB+ZC  # Compute for specific terms only gcor(mod, terms = c(\"X\", \"ZC\")) #>   terms       gcor null_model #> 1    ~X -0.1174534   ~1+ZB+ZC #> 2   ~ZC  0.7651942    ~1+ZB+X  gcor(mod, terms = c(\"X\", \"ZC\"),normalize=TRUE) #>    terms          r        r_n null_model   algorithm is.exact #> X     ~X -0.1174534 -0.1174534   ~1+ZB+ZC from theory     TRUE #> ZC   ~ZC  0.7651942  0.7651942    ~1+ZB+X from theory     TRUE   gcor(mod, intercept_too=TRUE, normalize=TRUE) #> Warning: The Normalized Generalized Partial Correlation (Determination) Coefficient for Count families without interncept in the null model has not implemented, yet. NA will be returned. #>                    terms          r        r_n null_model   algorithm is.exact #> (Intercept) ~(Intercept) -0.1265802         NA ~1+ZB+ZC+X        <NA>       NA #> ZB                   ~ZB -0.1080979 -0.1080979    ~1+ZC+X from theory     TRUE #> ZC                   ~ZC  0.7651942  0.7651942    ~1+ZB+X from theory     TRUE #> X                     ~X -0.1174534 -0.1174534   ~1+ZB+ZC from theory     TRUE set.seed(123) dt=data.frame(X=rnorm(20),    Z=factor(rep(LETTERS[1:3],length.out=20))) dt$Y=rbinom(n=20,prob=plogis((dt$Z==\"C\")*2),size=1) mod=flipscores(Y~Z+X,data=dt,family=\"binomial\",n_flips=1000) summary(mod) #>  #> Call: #> flipscores(formula = Y ~ Z + X, family = \"binomial\", data = dt,  #>     n_flips = 1000) #>  #> Coefficients: #>             Estimate    Score Std. Error  z value Part. Cor Pr(>|z|)   #> (Intercept)  -0.1486  -0.2102     1.1881  -0.1770    -0.067    0.893   #> ZB          -20.4539  -1.4784     0.7466  -1.9802    -0.530    0.060 . #> ZC           20.8561   1.8043     0.8180   2.2057     0.615    0.031 * #> X            -0.4276  -0.3782     0.9574  -0.3951    -0.149    0.762   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 27.5256  on 19  degrees of freedom #> Residual deviance:  9.4015  on 16  degrees of freedom #> AIC: 17.401 #>  #> Number of Fisher Scoring iterations: 19 #>   (results <- gcor(mod,normalize=TRUE)) #>    terms          r        r_n null_model   algorithm is.exact #> ZB   ~ZB -0.5295718 -0.5304792    ~1+ZC+X multi_start    FALSE #> ZC   ~ZC  0.6146304  0.6148542    ~1+ZB+X multi_start    FALSE #> X     ~X -0.1493213 -0.1891066   ~1+ZB+ZC multi_start    FALSE # Compute for specific terms only gcor(mod, terms = c(\"X\", \"ZC\"),normalize=TRUE) #>    terms          r        r_n null_model   algorithm is.exact #> X     ~X -0.1493213 -0.1891066   ~1+ZB+ZC multi_start    FALSE #> ZC   ~ZC  0.6146304  0.6148542    ~1+ZB+X multi_start    FALSE"},{"path":"https://livioivil.github.io/flipscores/reference/make_flips.html","id":null,"dir":"Reference","previous_headings":"","what":"It creates a n_flipsxn_obs matrix of random +1 and -1. The first row is made by ones (i.e. the observed test statistic is computed) — make_flips","title":"It creates a n_flipsxn_obs matrix of random +1 and -1. The first row is made by ones (i.e. the observed test statistic is computed) — make_flips","text":"creates n_flipsxn_obs matrix random +1 -1. first row made ones (.e. observed test statistic computed)","code":""},{"path":"https://livioivil.github.io/flipscores/reference/make_flips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"It creates a n_flipsxn_obs matrix of random +1 and -1. The first row is made by ones (i.e. the observed test statistic is computed) — make_flips","text":"","code":"make_flips(n_obs, n_flips)"},{"path":"https://livioivil.github.io/flipscores/reference/make_flips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"It creates a n_flipsxn_obs matrix of random +1 and -1. The first row is made by ones (i.e. the observed test statistic is computed) — make_flips","text":"n_obs number observations n_flips number flips","code":""},{"path":"https://livioivil.github.io/flipscores/reference/make_flips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"It creates a n_flipsxn_obs matrix of random +1 and -1. The first row is made by ones (i.e. the observed test statistic is computed) — make_flips","text":"","code":"# example code make_flips(n_obs=10,n_flips=20) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    1    1    1    1    1    1    1    1     1 #>  [2,]    1   -1    1    1   -1    1    1   -1    1    -1 #>  [3,]   -1    1    1    1   -1    1   -1   -1    1    -1 #>  [4,]   -1   -1    1   -1    1    1   -1   -1    1    -1 #>  [5,]    1   -1   -1   -1   -1   -1    1    1   -1    -1 #>  [6,]    1    1   -1   -1    1   -1    1   -1    1     1 #>  [7,]    1   -1   -1   -1    1   -1   -1   -1   -1     1 #>  [8,]    1    1    1   -1    1   -1    1    1   -1     1 #>  [9,]    1    1    1   -1   -1    1    1    1   -1     1 #> [10,]    1   -1    1   -1    1    1   -1    1   -1     1 #> [11,]    1    1   -1    1    1    1    1   -1   -1     1 #> [12,]    1    1   -1    1   -1    1   -1   -1    1     1 #> [13,]   -1    1   -1   -1   -1    1    1    1   -1    -1 #> [14,]   -1    1    1    1   -1    1   -1    1   -1     1 #> [15,]    1    1   -1   -1   -1   -1   -1   -1    1     1 #> [16,]   -1    1   -1    1   -1   -1   -1   -1   -1    -1 #> [17,]   -1    1    1    1   -1    1    1   -1    1    -1 #> [18,]    1   -1    1   -1    1   -1   -1   -1   -1    -1 #> [19,]   -1   -1   -1    1    1    1    1   -1    1     1 #> [20,]    1    1    1    1   -1   -1    1   -1    1     1"}]
