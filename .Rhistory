library(flipscores)
library(MASS)
library(foreach)
library(doParallel)
library(mvtnorm)
#CASO POISSON
n=100
B=5000
set.seed(1234567)
matrixcor<-matrix(c(1.0,  0.1,  0.5,  0.5,
0.1,  1.0,  0.1,  0.1,
0.5,  0.1,  1.0,  0.1,
0.5,  0.1,  0.1,  1.0),4,4)
dati<-data.frame(mvrnorm(n,c(0,0,0,0), Sigma = matrixcor))
colnames(dati)<-c("X","Z", "Z1", "Z2")
betacoeff<-c(1,1,1,2)
dati$Y=rpois(n,lambda=exp(betacoeff[1]*dati$X+betacoeff[2]*dati$Z+betacoeff[3]*dati$Z1+betacoeff[4]*dati$Z2))
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"))
summary(mod1)
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"),flips=FLIPS)
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"),flips=FLIPS)
summary(mod1)
mod2=flipscores(mod1,flips=FLIPS)
summary(mod2)
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"))
summary(mod1)
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(flipscores(mod$formula,mod$family,mod$data,offset=betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
mod.glm=glm(Y~X+Z+Z1+Z2,data=dati,family="poisson")
mod.fs1=flipscores(mod.glm)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = 1.9)
mod.fs1=flipscores(mod.glm)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = 1.9)
library(flipscores)
library(MASS)
library(foreach)
library(doParallel)
library(mvtnorm)
#CASO POISSON
n=100
B=5000
set.seed(1234567)
matrixcor<-matrix(c(1.0,  0.1,  0.5,  0.5,
0.1,  1.0,  0.1,  0.1,
0.5,  0.1,  1.0,  0.1,
0.5,  0.1,  0.1,  1.0),4,4)
dati<-data.frame(mvrnorm(n,c(0,0,0,0), Sigma = matrixcor))
colnames(dati)<-c("X","Z", "Z1", "Z2")
betacoeff<-c(1,1,1,2)
dati$Y=rpois(n,lambda=exp(betacoeff[1]*dati$X+betacoeff[2]*dati$Z+betacoeff[3]*dati$Z1+betacoeff[4]*dati$Z2))
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"),flips=FLIPS)
summary(mod1)
mod2=flipscores(mod1,flips=FLIPS)
summary(mod2)
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"))
summary(mod1)
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(flipscores(mod$formula,mod$family,mod$data,offset=betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
mod.glm=glm(Y~X+Z+Z1+Z2,data=dati,family="poisson")
mod.fs1=flipscores(mod.glm)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = 1.9)
PVal.Flip(mod.fs1, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = 1.9)
PVal.Flip(mod.fs2, betaH0 = 2.1)
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(flipscores(mod,offset=betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
PVal.Flip(mod.fs1, betaH0 = 1.9)
PVal.Flip(mod.fs1, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = 1.9)
PVal.Flip(mod.fs2, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = 0)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -2)
PVal.Flip(mod.fs2, betaH0 = 2.1)
mod.fs2$p.values
PVal.Flip(mod.fs2, betaH0 = 2.1, alternative="greater")
PVal.Flip(mod.fs2, betaH0 = 21, alternative="greater")
PVal.Flip(mod.fs2, betaH0 = 210, alternative="greater")
mod.fs2
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(update(mod,offset=betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
PVal.Flip(mod.fs1, betaH0 = 1.9)
PVal.Flip(mod.fs1, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -2)
PVal.Flip(mod.fs2, betaH0 = 2.1)
mod.fs1
mod.fs2
PVal.Flip(mod.fs2, betaH0 = 2.1)
PVal.Flip(mod.fs2, betaH0 = 1.99153144)
PVal.Flip(mod.fs2, betaH0 = -1.99153144)
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(update(mod,offset=-betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
mod.glm=glm(Y~X+Z+Z1+Z2,data=dati,family="poisson")
mod.fs1=flipscores(mod.glm)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = 1.9)
PVal.Flip(mod.fs1, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -2)
PVal.Flip(mod.fs2, betaH0 = 2.1)
PVal.Flip(mod.fs1, betaH0 = -20)
PVal.Flip(mod.fs1, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -20)
PVal.Flip(mod.fs2, betaH0 = 2.1)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -5)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -3)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -2)
#diversi da
PVal.Flip(mod.fs2, betaH0 = -3)
PVal.Flip(mod.fs2, betaH0 = 2.1)
coefficients(mod.fs2)
PVal.Flip(mod.fs2, betaH0 = coefficients(mod.fs2)["Z2"])
PVal.Flip(mod.fs1, betaH0 = coefficients(mod.fs2)["Z2"])
PVal.Flip(mod.fs1, betaH0 = -3)
mod.fs1=flipscores(mod.glm,flips = FLIPS)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data,flips=FLIPS)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = -3)
library(flipscores)
library(MASS)
library(foreach)
library(doParallel)
library(mvtnorm)
#CASO POISSON
n=100
B=5000
set.seed(1234567)
matrixcor<-matrix(c(1.0,  0.1,  0.5,  0.5,
0.1,  1.0,  0.1,  0.1,
0.5,  0.1,  1.0,  0.1,
0.5,  0.1,  0.1,  1.0),4,4)
dati<-data.frame(mvrnorm(n,c(0,0,0,0), Sigma = matrixcor))
colnames(dati)<-c("X","Z", "Z1", "Z2")
betacoeff<-c(1,1,1,2)
dati$Y=rpois(n,lambda=exp(betacoeff[1]*dati$X+betacoeff[2]*dati$Z+betacoeff[3]*dati$Z1+betacoeff[4]*dati$Z2))
mod1=flipscores(Y~X+Z+Z1+Z2,data=dati,family="poisson"(link="log"))
summary(mod1)
set.seed(1)
FLIPS=make_flips(n_obs=nrow(mod1$scores),n_flips=mod1$flip_param_call$n_flips)
PVal.Flip=function(mod, betaH0=0,x="Z2", alternative="less", B=5000, flips=FLIPS) {
xvals=model.matrix(mod)[,x]
as.numeric(update(mod,offset=-betaH0*xvals,to_be_tested = x,
flips=flips, alternative=alternative)$p.values)
}
mod.glm=glm(Y~X+Z+Z1+Z2,data=dati,family="poisson")
mod.fs1=flipscores(mod.glm,flips = FLIPS)
mod.fs2=flipscores(formula=mod.glm$formula, family=mod.glm$family, data=mod.glm$data,flips=FLIPS)
summary(mod.fs1)
summary(mod.fs2)
PVal.Flip(mod.fs1, betaH0 = -3)
PVal.Flip(mod.fs1, betaH0 = coefficients(mod.fs2)["Z2"])
#diversi da
PVal.Flip(mod.fs2, betaH0 = -3)
PVal.Flip(mod.fs2, betaH0 = coefficients(mod.fs2)["Z2"])
setwd("../flip")
library(devtools)
check()
check()
build()
build()
build()
build()
build()
round(c((seq(10,5000,length.out=7))),0)
round(c((seq(10,1000,length.out=7))),0)
round(c((seq(10,1000,length.out=10))),0)
round(c((seq(10,5000,length.out=8))),0)
round(c((seq(10,1000,length.out=6))),0)
10^(seq(1,3,length.out=7)))
10^(seq(1,3,length.out=7))
10^(seq(1,4,length.out=7))
10^(seq(1,4,length.out=9))
10^(seq(1,4,length.out=8))
10^(seq(1,4,length.out=7))
10^(seq(1,4,length.out=10))
setwd("../bluetits/")
devtools::check()
pkgbuild::check_build_tools(debug = TRUE)
remove("Rtools")
remove(Rtools)
devtools::check()
pkgbuild::check_build_tools(debug = TRUE)
remove.packages("Rtools")
remove.packages("Rtool")
install.packages("Rtool")
"Rtool" %in% available.packages()[,1]
devtools::check()
devtools::load_all()
set.seed(1)
dt=data.frame(X=rnorm(20),
Z=factor(rep(LETTERS[1:3],length.out=20)))
dt$Y=rpois(n=20,lambda=exp(dt$Z=="C"))
mod=flipscores(Y~Z+X,data=dt,family="poisson",n_flips=1000)
summary(mod)
# Compute generalized partial correlations for all terms
(results <- gcor(mod))
devtools::load_all()
(results <- gcor(mod))
(results <- gcor(mod))
has_intercept
full_glm$formula
null_frml
null_frml <- "~ 1"
null_model = paste0(null_frml,
sapply(terms,function(i) paste0(setdiff(all_vars,i),collapse   ="+"))
)
null_model
all_vars
sapply(terms,function(i) paste0(setdiff(all_vars,i),collapse   ="+"))
all_vars= c(null_frml,all_vars)
sapply(terms,function(i) paste0(setdiff(all_vars,i),collapse   ="+"))
devtools::load_all()
(results <- gcor(mod))
devtools::load_all()
set.seed(123)
dt=data.frame(X=rnorm(20),
Z=factor(rep(LETTERS[1:3],length.out=20)))
dt$Y=rbinom(n=20,prob=plogis((dt$Z=="C")*2),size=1)
mod=flipscores(Y~Z+X,data=dt,family="binomial",n_flips=1000)
# Compute for specific terms only
(results <- gcor_normalized_binom(mod))
(results <- gcor_normalized_binom(mod))
devtools::load_all()
set.seed(123)
dt <- data.frame(X = rnorm(20),
Z = factor(rep(LETTERS[1:3], length.out = 20)))
dt$Y <- rbinom(n = 20, prob = plogis((dt$Z == "C") * 2), size = 1)
mod <- glm(Y ~ Z + X, data = dt, family = binomial)
# Compute generalized partial correlations for all variables
(results <-  gR2_normalized_binom(mod))
devtools::load_all()
(results <-  gR2_normalized_binom(mod))
devtools::load_all()
(results <-  gR2_normalized_binom(mod))
(results <-  gR2(mod))
(results <-  gR2(mod))
temp$null_glm
temp$X
temp$terms
terms
get_X
devtools::load_all()
(results <-  gR2(mod))
devtools::load_all()
(results <-  gR2(mod))
(results <-  gR2_normalized_binom(mod))
(results <-  gR2_normalized_binom(mod))
devtools::load_all()
(results <-  gR2_normalized_binom(mod))
(results <- gR2(mod))
mod0=glm(Y~0,data=dt,family="poisson")
(results <- gR2(mod, mod0))
mod0=glm(Y~0,data=dt,family="binomial")
(results <- gR2(mod, mod0))
debugSource("~/github/flipscores/R/gR2.R")
devtools::load_all()
rm(list = c("gR2"))
(results <- gR2(mod, mod0))
source("~/github/flipscores/R/gR2.R")
(results <- gR2(mod, mod0))
debugSource("~/github/flipscores/R/gR2.R")
(results <- gR2(mod, mod0))
debugSource("~/github/flipscores/R/gR2.R")
(results <- gR2(mod, mod0))
devtools::load_all()
rm(list = c("gR2"))
(results <- gR2(mod, mod0))
mod=full_glm
full_glm=mod
all.vars(full_glm$formula)
all.vars(full_glm$formula)[-1]
all_vars <- all.vars(full_glm$formula)[-1]
all_vars
terms(full_glm$formula)
debugSource("~/github/flipscores/R/gR2.R")
(results <- gR2(mod, mod0))
(results <- gR2(mod, mod0))
terms
temp=.prepare_for_gR2(full_glm,null_glm,terms)
temp
temp$X
source("~/github/flipscores/R/gR2.R")
source("~/github/flipscores/R/gR2.R")
devtools::load_all()
rm(list = c("gR2"))
devtools::load_all()
(results <- gR2(mod, mod0))
(results <- gR2(mod, mod0))
(results <- gR2(mod, mod0))
terms
temp=lapply(terms,.socket_compute_gR2,full_glm, null_glm)
temp
(results <- gR2(mod, mod0))
debug(.socket_compute_gR2)
(results <- gR2(mod, mod0))
(results <- gR2(mod, mod0))
debug(.socket_compute_gR2)
temp=.prepare_for_gR2(full_glm,null_glm,terms)
debugSource("~/github/flipscores/R/gR2.R")
devtools::load_all()
rm(list = c("gR2"))
devtools::load_all()
(results <- gR2(mod, mod0))
source("~/github/flipscores/R/gR2.R")
devtools::load_all()
rm(list = c("gR2"))
devtools::load_all()
(results <- gR2(mod, mod0))
(results <- gR2(mod))
source("~/github/flipscores/R/gR2.R")
(results <- gcor(mod))
set.seed(1)
dt=data.frame(X=rnorm(20),
Z=factor(rep(LETTERS[1:3],length.out=20)))
dt$Y=rpois(n=20,lambda=exp(dt$Z=="C"))
mod=flipscores(Y~Z+X,data=dt,family="poisson",n_flips=1000)
summary(mod)
# Compute generalized partial correlations for all terms
(results <- gcor(mod))
mod0=glm(Y~1,data=dt,family="poisson")
(results <- gR2(mod, mod0))
(results <- gcor(mod, mod0))
(results <- gcor(mod))
mod0
(results <- gcor(mod, mod0))
gcor(mod, terms = c("X", "ZC"))
devtools::load_all()
rm(list = c("gR2"))
(results <- gcor(mod, mod0))
missing_vars
all_vars
terms
library(devtools)
document()
install()
usethis::use_pkgdown_github_pages()
devtools::document()
pkgdown::build_home_index(".")
pkgdown::init_site(".")
pkgdown::build_home_index()
?gR2_normalized_binom
set.seed(123)
dt <- data.frame(X = rnorm(20),
Z = factor(rep(LETTERS[1:3], length.out = 20)))
dt$Y <- rbinom(n = 20, prob = plogis((dt$Z == "C") * 2), size = 1)
mod <- glm(Y ~ Z + X, data = dt, family = binomial)
# Compute generalized partial correlations for all variables
(results <-  gR2_normalized_binom(mod))
# equivalent to
mod0=glm(Y~1,data=dt,family=binomial)
(results <-  gR2_normalized_binom(mod, mod0))
# Compute for specific variables only
(results <-  gR2_normalized_binom(mod,terms = c("X","Z")))
pkgdown::build_home_index()
pkgdown::build_home()
pkgdown::build_reference()
pkgdown::build_reference_index()
